
% Research and Analyse!
% Show Specialist Knowledge!
% Communicate Effectively!
% Experiment Effectively!

\documentclass[11pt, a4paper, twocolumn]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{titlesec}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[font={small, it}, labelfont=bf, center]{caption}
\usepackage[top=1cm, left=1cm, right=1cm, bottom=2cm]{geometry}

\usepackage{helvet} % Helvetica 'phv'
\usepackage{mathptmx} % Times 'ptm'

\urlstyle{same}

\titleformat{\section}
  {\sffamily\bfseries\Large} % format
  {\thesection} % label
  {1em} % label separation
  {} % before-code

\titleformat{\subsection}
  {\sffamily\bfseries} % format
  {\thesubsection} % label
  {1em} % label separation
  {} % before-code

\title{\sffamily\bfseries Development Journal: Vulkan \& Particle Systems}
\author{Robin Wragg}
\date{\today}

\begin{document}

\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Moving Away from IMUs(?)}

\section{Preliminary Library Choices}

Why sdl? why glm?

\section{Initialising Vulkan}

Decided to create a flat function with well-subscoped sections. (carmack)

created a batch file that stays open only if errors occur

I started following some tutorials for initialising Vulkan, but I found they advised implementing things that I didn't need, so I found it best to read tutorials only as a convenient place to find out what order different parts of the API should to be called, and then I would decide which parts I needed and what code structure was best, while reading the API reference for each function to make sure I didn't miss any important details.

I usually like to categorise my program into separate functions or classes as I go, as I think we all do, as it's generally good to write code that separates concerns. But Vulkan's setup code isn't particularly easy to divide into independent sections, \emph{e.g.} we might want to isolate \verb|VkQueue| creation from the rest of the setup, but we can't do that neatly because it depends on the capabilities of the \verb|VkPhysicalDevice|; the \verb|VkQueue| then needs to be created at the same time as the \verb|VkDevice| (the \emph{logical} device).

So I followed the advice of Carmack (TODO: cite) and kept the majority of the API calls in one function (\verb|gfx::init()|), using well-subscoped sections to guarantee the lifetimes of variables, and I only implemented additional functions if those functions were "getters" that didn't have many dependencies/parameters and didn't modify the state outside of their own scope. This enabled me to view the entire collection of setup API calls with very little clutter.

% TODO: cite: http://number-none.com/blow/john_carmack_on_inlined_code.html

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{agsm}
\bibliography{mendeley_refs, other_refs}

% TODO: appendix entry with full details of the computer - include the protocol and theoretical speed of the GPU's bus etc.
% TODO: appendix entry with notes on Vulkan on macOS with MoltenVK

\end{document}





